/*
================================================================================
Server-Side Freeze-Tag Gametype Library
for Medal Of Honor
Version 1.2.3 (11/15/04)

Copyright (c) 2003-2004 Mark Follett
email: mef123@geocities.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
================================================================================
*/


ft_begin:
	level.ft_running = 1
	level.ft_version = "1.2.3"
	setcvar "g_ft_version" level.ft_version

	waitthread global/libmef/util.scr::read_gametype_settings

	level.mef_pchudenabled = 1
	level.mef_pchudx = 10
	level.mef_pchudy = -140
	level.mef_dmrespawning = 0
	level.mef_freezemode = 1
	level.mef_allies.respawn = 0
	level.mef_allies.freezemode = 1
	level.mef_axis.respawn = 0
	level.mef_axis.freezemode = 1

	if (level.mef_gametype == "ftobj")
	{
		level.mef_checkwinthread = global/libmef/respawn.scr::get_winner_obj
	} else if (level.mef_gametype == "fttow")
	{
		level.mef_checkwinthread = global/libmef/respawn.scr::get_winner_tow
		level.mef_allies.waverespawn = 1
		level.mef_axis.waverespawn = 1
	} else
	{
		level.mef_checkwinthread = global/libmef/respawn.scr::get_winner_rb
	}

	level.mef_credits[0] = "Freeze-Tag MOD"
	level.mef_credits[1] = ("Version " + level.ft_version)
	level.mef_credits[2] = "by Mefy"
	level.mef_credits[3] = "planetmedalofhonor.com/"
	level.mef_credits[4] = "mefy"
	level.mef_credits[5] = ""

	if (level.mef_gametype == "ft")
	{
		if (level.mef_maptype == "obj")
		{
			level.mef_basegametype = 4 // Objective-Match
		} else
		{
			level.mef_basegametype = 3 // Round-Based-Match
		}

		if (level.mef_settings["meltgun"])
		{
			setcvar "g_obj_alliedtext1" "Stand next to a frozen"
			setcvar "g_obj_alliedtext2" "teammate to melt them"
			setcvar "g_obj_alliedtext3" "or hold Use(e) to fire"
			setcvar "g_obj_axistext1" "your melting laser"
			setcvar "g_obj_axistext2" ("Freeze-Tag MOD " + level.ft_version)
			setcvar "g_obj_axistext3" "by Mefy"
		} else
		{
			setcvar "g_obj_alliedtext1" "Freeze the enemy team"
			setcvar "g_obj_alliedtext2" "Stand next to a frozen"
			setcvar "g_obj_alliedtext3" "teammate to melt them"
			
			if (level.mef_basegametype == 4)
			{
				setcvar "g_obj_axistext1" ("Freeze-Tag MOD " + level.ft_version)
				setcvar "g_obj_axistext2" "by Mefy"
				setcvar "g_obj_axistext3" ""
			} else
			{
				setcvar "g_obj_axistext1" ""
				setcvar "g_obj_axistext2" ("Freeze-Tag MOD " + level.ft_version)
				setcvar "g_obj_axistext3" "by Mefy"
			}
		}
	} else if (level.mef_gametype == "ftobj")
	{
		// Freeze-Tag-Objective
		level.mef_basegametype = 4 // Objective-Match
	} else
	{
		// Freeze-Tag-TOW
		level.mef_basegametype = 5 // Tug-of-War
	}

	setcvar "g_gametype" level.mef_basegametype

	waitthread global/libmef/mapdesc.scr::setup_map level.mef_mapname

	level waittill prespawn

	if (level.mef_gametype == "ft")
	{
		level.dmroundlimit = 7 // round time limit in minutes
	}
	
	level waittill spawn

	if (!level.mef_devmode)
	{
		level waittill roundstart
	}

	waitthread global/libmef/hud.scr::init_suddendeath_hud

	local.sdmins = 0
	local.autonuke = 0

	if (level.mef_gametype == "fttow")
	{
		// freeze tag tow
		level commanddelay 0 ignoreclock 1
	} else
	{
		if (level.mef_gametype == "ft")
		{
			waitthread global/libmef/util.scr::turn_off_clock
			local.autonuke = 1
		} else
		{
			// freeze tag objective
			level.bombs_planted = 1
			level.bomb_set = 1
		}
		
		if (level.mef_settings["suddendeath"] > 0)
		{
			local.sdmins = level.mef_settings["suddendeath"]
		}
	}

	thread global/libmef/respawn.scr::round_thread local.sdmins local.autonuke
end


read_game_settings:
	local.settingsdef[0] = NIL
	if (level.mef_gametype != "fttow")
	{
		local.settingsdef[0] = "suddendeath"::int::1
	}
	waitthread append_ft_settingsdef local.settingsdef

	waitthread global/libmef/util.scr::read_game_settings level.mef_settings local.settingsdef
end


append_ft_settingsdef local.settingsdef:
	local.ft_settingsdef[0] = "melttime"::int::20
	local.ft_settingsdef[1] = "meltradius"::int::100
	local.ft_settingsdef[2] = "meltgun"::bool::1
	local.ft_settingsdef[3] = "ftannounce"::string::"hudmessages frozen melted bodycodes"

	waitthread global/libmef/util.scr::append_arrays local.settingsdef local.ft_settingsdef
end


init_ft_respawnmode:
	waitthread global/libmef/util.scr::read_options level.mef_settings["ftannounce"] "ftannounce" hudmessages::frozen::melted::bodycodes

	level.ft_meltrate = 0.006

	level.ft_deathanims[0] = "death_fall_to_knees"
	level.ft_deathanims[1] = "death_fall_back"
	level.ft_deathanims[2] = "death_chest"
	level.ft_deathanims[3] = "death_choke"
	level.ft_deathanims[4] = "death_crotch"
	level.ft_deathanims[5] = "death_headpistol"
	level.ft_deathanims[6] = "death_frontchoke"
	level.ft_deathanims[7] = "death_twist"
	level.ft_deathanims[8] = "death_collapse"
	level.ft_deathanims[9] = "death_shoot"

	level.ft_lasersound["allies"] = "m2l3_machine_loop"
	level.ft_lasersound["axis"] = "m2l3_radio1"
	level.ft_meltingsound = "welding_torch"
	level.ft_laservolume = 1.0

	level.ft_frozencolor["allies"] = ( 0.0 0.0 1.0 )
	level.ft_frozencolor["axis"] = ( 1.0 0.0 0.0 )
	level.ft_meltingcolor["allies"] = ( 0.0 1.0 1.0 )
	level.ft_meltingcolor["axis"] = ( 1.0 1.0 0.0 )
	level.ft_enemycolor["allies"] = ( 0.4 0.0 1.0 )
	level.ft_enemycolor["axis"] = ( 1.0 0.0 0.4 )
	level.ft_enemymeltcolor["allies"] = ( 0.5 1.0 1.0 )
	level.ft_enemymeltcolor["axis"] = ( 1.0 1.0 0.5 )
	
	if (level.mef_settings["melttime"] < 1)
	{
		level.mef_settings["melttime"] = 1
	}

	if (level.mef_settings["meltgun"])
	{
		thread auto_collision_check
	}

	thread global/libmef/util.scr::auto_broadcast_ents 0.5
end


team_shatter local.team:
	level.mef_team[local.team].spawnfrozenbodies = 0
	waitthread clear_flags local.team
	waitthread collapse_frozen_bodies local.team
end


clear_flags local.team:
	for (local.i = 0; local.i < level.mef_players.size; local.i++)
	{
		local.player = level.mef_players[local.i].player

		if (local.player != NULL && local.player.dmteam == local.team)
		{
			local.player.ft_spawnfrozenbody = NIL
			local.player.ft_meltplayer = NIL
		}
	}
end


create_frozen_body local.player local.origin:
	local.ent = spawn script_model
	local.ent model local.player.model
	local.ent.origin = local.origin
	local.ent.angles = local.player.angles
	local.ent notsolid
	local.ent.freezetime = level.time
	local.ent.player = local.player
	local.ent.team = local.player.dmteam
	local.ent.targetname = ("frozenbody_" + local.ent.team)
	local.ent.melters[0] = NIL
	local.ent.meltbeams[0] = NIL
	local.ent.addedplayer = 0
	local.ent.frozen = 1
	
	local.ent.melttrigger = waitthread spawn_melt_trigger local.ent level.mef_settings["meltradius"]
	local.ent jumpto (trace (local.ent.origin + ( 0 0 30 )) (local.ent.origin + ( 0 0 -10000 )) 0 ( -5 -5 0 ) ( 5 5 0 ))
	local.ent.specorg = trace (local.ent.origin + ( 0 0 30 )) (local.ent.origin + ( 0 0 100 ))

	local.ent.frozencolor = level.ft_frozencolor[local.player.dmteam]
	local.ent.meltingcolor = level.ft_meltingcolor[local.player.dmteam]
	local.ent.enemycolor = level.ft_enemycolor[local.player.dmteam]
	local.ent.enemymeltcolor = level.ft_enemymeltcolor[local.player.dmteam]

	local.ent.beams = waitthread spawn_beam_cylinder local.ent.origin 15 local.ent.frozencolor

	level.mef_broadcastents[level.mef_broadcastents.size] = local.ent

	local.ent.freezelocabbr = waitthread global/libmef/mapdesc.scr::get_player_position_abbr local.ent.origin
	waitthread add_body_to_list local.ent

	waitthread announce_body_position local.ent local.player.dmteam "frozen"

	local.player.mef_auxdata.frozenbody = local.ent
	
	thread body_color_thread local.ent
end local.ent


spawn_melt_trigger local.body local.meltdist:
	local.bbox = local.meltdist * 0.7
	local.ent = spawn trigger_multiple
	local.ent.origin = local.body.origin
	local.ent setsize ( -local.bbox -local.bbox -local.bbox ) ( local.bbox local.bbox local.bbox )
	local.ent.body = local.body
	local.ent.meltdist = local.meltdist
	local.ent setthread run_melt_trigger
	local.ent glue local.body
end local.ent


run_melt_trigger:
	if (self != NULL && self.body != NULL && parm.other != NULL)
	{
		if (parm.other.dmteam == self.body.team)
		{
			waitthread melt_body self.body parm.other
		} else
		{
			thread enemy_nearby_thread self.body parm.other
		}
	}
end


enemy_nearby_thread local.body local.player:
	if (local.body.melted || local.body.enemy_nearby)
	{
		end
	}
	
	local.team = local.player.dmteam
	local.body.enemy_nearby = 1
	
	while ((local.body != NULL) && (local.body.melttrigger != NULL) && (local.body.player != NULL) && (local.body.player.dmteam == local.body.team) && (local.body.player.mef_gstate == "GSTATE_DEAD") && \
	       (local.player != NULL) && (local.player.dmteam == local.team) && (Isalive local.player) && (local.player.mef_gstate == "GSTATE_ALIVE") && \
	       (local.player cansee local.body 360 50))
	{
		waitframe
	}
	
	if (local.body != NULL)
	{
		local.body.enemy_nearby = 0
	}
end


body_color_thread local.body:
	local.melting = local.body.melting
	local.enemy_nearby = local.body.enemy_nearby

	while ((local.body != NULL) && (local.body.melttrigger != NULL) && (local.body.player != NULL) && (local.body.player.dmteam == local.body.team) && (local.body.player.mef_gstate == "GSTATE_DEAD"))
	{
		if (local.melting != local.body.melting || local.enemy_nearby != local.body.enemy_nearby)
		{
			local.melting = local.body.melting
			local.enemy_nearby = local.body.enemy_nearby
			
			if (!local.melting && !local.enemy_nearby)
			{
				local.color = local.body.frozencolor
			} else if (local.melting && !local.enemy_nearby)
			{
				local.color = local.body.meltingcolor
			} else if (!local.melting && local.enemy_nearby)
			{
				local.color = local.body.enemycolor
			} else
			{
				local.color = local.body.enemymeltcolor
			}
			
			if (local.body.beams != NIL)
			{
				for (local.i = 0; local.i < local.body.beams.size; local.i++)
				{
					local.body.beams[local.i] color local.color
				}

			}
		}
		
		waitframe
	}
end


melt_body local.body local.player local.beam:
	if (local.body.melted)
	{
		end
	}

	for (local.i = 0; local.i < local.body.melters.size; local.i++)
	{
		if (local.player == local.body.melters[local.i])
		{
			end
		}
	}
	
	local.body.melters[local.body.melters.size] = local.player
	local.body.meltbeams[local.body.meltbeams.size] = local.beam
	local.body.addedplayer = 1
	
	if (!local.body.frozen)
	{
		end
	}
	
	local.body.frozen = 0

	local.freq = 5
	local.baserate = (1.0 / (level.mef_settings["melttime"] * 0.1))
	
	local.melters = local.body.melters
	local.flevel = 0.0

	while ((local.body != NULL) && (local.body.melttrigger != NULL) && (local.body.player != NULL) && (local.body.player.dmteam == local.body.team) && (local.body.player.mef_gstate == "GSTATE_DEAD"))
	{
		local.removedplayer = 0
		local.contrib = 0.0

		local.initsize = local.melters.size
	
		// check the existing melters
		for (local.i = 0; local.i < local.initsize; local.i++)
		{
			local.player = local.melters[local.i]
			local.beam = local.body.meltbeams[local.i]

			if ((local.player != NULL) && (local.player.dmteam == local.body.team) && (Isalive local.player) && (local.player.mef_gstate == "GSTATE_ALIVE") && \
			    ((local.beam == NIL && (local.player cansee local.body 360 local.body.melttrigger.meltdist)) || \
                	     (local.beam != NIL && local.beam.laseron && (local.beam isTouching local.body))))
			{
				local.dist = (vector_length (local.player.origin - local.body.origin))
				local.thisrate = (1.0 / ((level.mef_settings["melttime"] + (local.dist * level.ft_meltrate)) * 0.1))
				local.contrib += (1.0 / (1.0 - (local.thisrate / (2.0 * local.baserate)))) - 1.0
			} else
			{
				// player is no longer melting the body
				if (local.player != NULL)
				{
					local.player stopwatch 0
				}
				local.melters[local.i] = NIL
				local.removedplayer = 1
			}
		}

		if (local.removedplayer)
		{
			local.newmelters = NIL
			local.newmelters[0] = NIL
			local.newmeltbeams = NIL
			local.newmeltbeams[0] = NIL
			
			for (local.i = 0; local.i < local.initsize; local.i++)
			{
				if (local.body.melters[local.i] != NIL)
				{
					local.newmelters[local.newmelters.size] = local.body.melters[local.i]
					local.newmeltbeams[local.newmeltbeams.size] = local.body.meltbeams[local.i]
				}
			}

			local.body.melters = local.newmelters
			local.body.meltbeams = local.newmeltbeams
			local.melters = local.body.melters
		}
	
		if (local.melters.size > 0)
		{
			local.rate = (1.0 - (1.0 / (local.contrib + 1.0))) * local.baserate * 2.0
		} else
		{
			local.rate = -local.baserate
		}

		if (local.lasttick != NIL)
		{
			local.elapsed = level.time - local.lasttick
		} else
		{
			local.elapsed = 0.0
		}
		
		local.lasttick = level.time
		local.flevel += local.rate * local.elapsed

		if (local.melters.size > 0 && !local.body.melting)
		{
			// starting to melt
			local.body.melting = 1
		} else if (local.melters.size == 0 && local.body.melting)
		{
			// stopped melting
			local.body.melting = 0
		}

		if (local.body.melting && local.flevel >= 1.0)
		{
			// melted
			local.body.melted = 1

			local.body playsound med_canteen
			local.body.player.ft_meltplayer = NIL
			local.body.player.ft_meltplayer[0] = NIL

			for (local.i = 0; local.i < local.melters.size; local.i++)
			{
				local.player = local.melters[local.i]
				local.player stopwatch 0
				local.body.player.ft_meltplayer[local.body.player.ft_meltplayer.size] = local.player
				if ((vector_length (local.player.origin - local.body.origin)) > 300)
				{
					local.player playsound med_canteen
				}
			}
			end
			
		} else if (local.body.melting)
		{
			if (local.body.addedplayer || local.removedplayer)
			{
				if (local.rate > 0.001)
				{
					local.melttime = (((1.0 - local.flevel) / local.rate) + 0.5)
				} else
				{
					local.melttime = 0.0
				}
				
				// re-stopwatch
				for (local.i = 0; local.i < local.melters.size; local.i++)
				{
					local.player = local.melters[local.i]
					local.player stopwatch local.melttime
				}
			}
		} else if (!local.body.melting && local.flevel <= 0.0)
		{
			// frozen again
			local.body.frozen = 1
			end
		}

		local.body.addedplayer = 0
		wait (1.0 / local.freq)
	}
	
	for (local.i = 0; local.i < local.melters.size; local.i++)
	{
		local.player = local.melters[local.i]
		if (local.player != NULL)
		{
			local.player stopwatch 0
		}
	}
end


add_body_to_list local.body:
	local.body.prevbody = level.ft_frozenbodies[local.body.team]
	local.body.nextbody = NIL
	
	if (local.body.prevbody != NIL)
	{
		local.body.prevbody.nextbody = local.body
	}
	
	level.ft_frozenbodies[local.body.team] = local.body
	level.mef_team[local.body.team].ftbodydesc = waitthread get_body_desc local.body.team
end


remove_body_from_list local.body:
	if (local.body.prevbody != NIL)
	{
		local.body.prevbody.nextbody = local.body.nextbody
	}
		
	if (local.body.nextbody != NIL)
	{
		local.body.nextbody.prevbody = local.body.prevbody
	}
		
	if (level.ft_frozenbodies[local.body.team] == local.body)
	{
		level.ft_frozenbodies[local.body.team] = local.body.prevbody
	}
	level.mef_team[local.body.team].ftbodydesc = waitthread get_body_desc local.body.team
end


get_first_frozen_body local.team:
	for (local.elem = level.ft_frozenbodies[local.team]; local.elem != NIL; local.elem = local.elem.prevbody)
	{
		local.result = local.elem
	}
end local.result


remove_frozen_body local.auxdata:
	if (local.auxdata.frozenbody != NIL)
	{
		waitthread add_frozenloc_to_list local.auxdata.frozenbody.origin local.auxdata.frozenbody.team
		local.auxdata.frozenbody.melttrigger remove
		waitthread remove_beam_cylinder local.auxdata.frozenbody.beams
		local.auxdata.frozenbody.beams = NIL
		waitthread remove_body_from_list local.auxdata.frozenbody
		local.auxdata.frozenbody remove
		local.auxdata.frozenbody = NIL
	}
end


create_frozen_bodies local.team:
	for (local.i = 0; local.i < level.mef_players.size; local.i++)
	{
		local.player = level.mef_players[local.i].player

		if (local.player != NULL && local.player.ft_spawnfrozenbody != NIL && local.player.dmteam == local.team)
		{
			waitthread create_frozen_body local.player local.player.ft_spawnfrozenbody
			local.player.ft_spawnfrozenbody = NIL
		}
	}
end


collapse_frozen_bodies local.team:
	local.bodies[0] = NIL

	for (local.elem = (waitthread get_first_frozen_body local.team); local.elem != NIL; local.elem = local.elem.nextbody)
	{
		local.bodies[local.bodies.size] = local.elem
		local.elem.melttrigger remove
		local.elem.player.mef_auxdata.frozenbody.targetname = NIL
		local.elem.player.mef_auxdata.frozenbody = NIL
	}

	level.ft_frozenbodies[local.team] = NIL
	level.mef_team[local.team].ftbodydesc = waitthread get_body_desc local.team
	thread collapse_and_remove_bodies local.bodies
end


collapse_and_remove_bodies local.bodies:
	for (local.i = 0; local.i < local.bodies.size; local.i++)
	{
		thread collapse_and_remove_body local.bodies[local.i]
		wait 0.4
	}
end


collapse_and_remove_body local.body:
	waitthread remove_beam_cylinder local.body.beams
	local.body.beams = NIL
	local.body.dontbroadcast = 1
	local.body svflags "-broadcast"
	waitframe
	local.body anim level.ft_deathanims[randomint(level.ft_deathanims.size)]
	wait 5
	local.body remove
end


freeze_player local.player:
	if (local.player.mef_team.spawnfrozenbodies)
	{
		local.player.ft_spawnfrozenbody = local.player.origin
	}
//	thread auto_melt 10 local.player
end


melt_player local.player:
	waitthread announce_body_position local.player.mef_auxdata.frozenbody local.player.dmteam "melted"
	waitthread remove_frozen_body local.player.mef_auxdata
	local.player.mef_gstate = "GSTATE_ALIVE"
	local.player.mef_spectator = 0
	waitthread award_melter_points local.player.ft_meltplayer
	local.player.ft_meltplayer = NIL
end


auto_melt local.delay local.player:
	wait local.delay
	local.player.ft_meltplayer = NIL
	local.player.ft_meltplayer[0] = $player[1]
end


player_entered_game local.player:
	if (local.player.mef_gstate == "GSTATE_ALIVE")
	{
		waitthread add_frozenloc_to_list local.player.origin local.player.dmteam
	} else
	{
		if (local.player.mef_team.spawnfrozenbodies)
		{
			local.player.ft_spawnfrozenbody = (waitthread pop_frozenloc_from_list local.player.dmteam)
		}
	}
	
	if (level.mef_settings["meltgun"])
	{
		thread laser_thread local.player
	}
end


award_melter_points local.melters:
	if (level.mef_baseversion == "sh" || level.mef_baseversion == "bt")
	{
		for (local.i = 0; local.i < local.melters.size; local.i++)
		{
			local.melter = local.melters[local.i]
			if (local.melter != NULL)
			{
				if (local.melter.ft_meltscore == NIL)
				{
					local.melter.ft_meltscore = 0.0
					local.melter.ft_awardedpoints = 0
				}

				local.melter.ft_meltscore += (1.0 / local.melters.size)
				local.totalpoints = int local.melter.ft_meltscore

				// round up to the nearest integer
				if ((local.melter.ft_meltscore - local.totalpoints) > 0.0)
				{
					local.totalpoints += 1
				}

				local.award = local.totalpoints - local.melter.ft_awardedpoints
				if (local.award > 0)
				{
					local.melter commanddelay 0 addKills local.award
					local.melter.ft_awardedpoints += local.award
				}
			}
		}
	}
end


get_body_desc local.team:
	local.result = ""

	if (level.map_enabled && (level.mef_team[local.team].numplayers > 0) && level.mef_settings["ftannounce_bodycodes"])
	{
		for (local.elem = (waitthread get_first_frozen_body local.team); local.elem != NIL; local.elem = local.elem.nextbody)
		{
			if (local.result != "")
			{
				local.result = local.result + "-"  + local.elem.freezelocabbr
			} else
			{
				local.result = local.elem.freezelocabbr
			}
		}
	
		if (local.result != "")
		{
			local.result = "[" + local.result + "]"
		}
	}
end local.result


spawn_beam_cylinder local.origin local.radius local.color:
	local.beams[0] = NIL
	waitthread spawn_doublebeam local.beams (local.origin + ( local.radius 0 0 )) local.color
	waitthread spawn_doublebeam local.beams (local.origin + ( -(local.radius * 0.5) (local.radius * 0.866) 0 )) local.color
	waitthread spawn_doublebeam local.beams (local.origin + ( -(local.radius * 0.5) -(local.radius * 0.866) 0 )) local.color
end local.beams


remove_beam_cylinder local.beams:
	for (local.i = 0; local.i < local.beams.size; local.i++)
	{
		local.beams[local.i] remove
	}
end


spawn_doublebeam local.beams local.origin local.color:
	local.pts = waitthread find_beam_endpoints (local.origin + ( 0 0 40 )) 60 -50
	local.beams[local.beams.size] = waitthread spawn_beam local.pts[0] local.pts[1] local.color
	if (local.pts[2] != NIL)
	{
		local.beams[local.beams.size] = waitthread spawn_beam local.pts[2] local.pts[3] local.color
	}
end


spawn_beam local.origin local.endpoint local.color:
	local.ent = spawn func_beam
	local.ent.origin = local.origin
	local.ent endpoint local.endpoint
	local.ent minoffset 0.0
	local.ent maxoffset 0.0
	local.ent scale 4.0
	local.ent color local.color
	local.ent alpha 0.5
	local.ent numsegments 1
	local.ent life 0
	local.ent damage $player[1] 0
	local.ent activate
	level.mef_broadcastents[level.mef_broadcastents.size] = local.ent
end local.ent


find_beam_endpoints local.center local.start local.end:
	local.top = (local.center + ( 0 0 local.start))
	local.bottom = (local.center + ( 0 0 local.end))
	local.result[0] = (trace local.center local.top 0)
	local.result[1] = (trace local.center local.bottom 0)

	local.offset = local.top[2] - local.result[0][2]
	if (local.offset > 5)
	{
		local.secondbeam = (trace local.top local.center 0)
		if (local.secondbeam != local.center)
		{
			// do a second beam
			local.result[2] = local.top
			local.result[3] = local.secondbeam
		}
	}
end local.result


announce_body_position local.body local.team local.action:
	local.teamprefix["allies"] = "Allied"
	local.teamprefix["axis"] = "Axis"

	if (level.mef_settings["ftannounce_hudmessages"])
	{
		local.str = local.teamprefix[local.team] + " player " + local.action + "."
	
		if (level.mef_settings[("ftannounce_" + local.action)])
		{
			local.str += (waitthread get_body_full_desc local.body)
		}
	
		if (local.action == "melted")
		{
			iprintln_noloc local.str
		} else
		{
			iprintlnbold_noloc local.str
		}
	}
end


get_body_full_desc local.body:
	local.desc = waitthread global/libmef/mapdesc.scr::get_player_position local.body.origin

	if (local.desc != "")
	{
		local.desc = " [" + local.desc + "]"
	}
end local.desc


laser_thread local.player:
	local.tag = "eyes bone"
	local.beamalpha = 0.7
	local.usedelay = 0.25
	local.team = local.player.dmteam
	local.bodytarget = "frozenbody_" + local.player.dmteam
	local.lightrad = 50

	local.lasercolor = level.ft_frozencolor[local.player.dmteam]
	local.laserhitcolor = level.ft_meltingcolor[local.player.dmteam]
	local.lasersound = level.ft_lasersound[local.player.dmteam]
	local.meltingsound = level.ft_meltingsound
	local.soundvol = level.ft_laservolume

	local.ent = spawn func_beam
	local.ent minoffset 0.0
	local.ent maxoffset 0.0
	local.ent numsegments 1
	local.ent life 0
	local.ent color local.lasercolor
	local.ent alpha local.beamalpha
	
	local.ent alwaysdraw

	local.ent.targetname = "meltbeam_" + local.player.dmteam
	local.ent setsize ( -local.lightrad -local.lightrad -local.lightrad ) ( local.lightrad local.lightrad local.lightrad )
	local.ent light local.lasercolor[0] local.lasercolor[1] local.lasercolor[2] (local.lightrad * 2)
	local.ent lightOff
	local.ent.player = local.player
	local.ent.team = local.team
	
	local.hitbody = 0
	local.canuse = 1

	while (local.player != NULL && local.player.dmteam == local.team)
	{
		if (!local.canuse && !local.player.useheld)
		{
			local.canuse = 1
		}
		
		if (local.player.useheld && local.canuse && !local.player.fireheld && local.player.mef_pstate == "PSTATE_ALIVE" && !local.player.mef_pressingbutton)
		{
			if (local.useheldtime == NIL)
			{
				local.useheldtime = level.time + local.usedelay
			} else if (level.time > local.useheldtime)
			{
				local.laserorigin = (local.player gettagposition local.tag)
				local.laservec = (angles_toforward local.player.viewangles)
				
				if ($(local.bodytarget) != NULL)
				{
					$(local.bodytarget) solid
				}
				
				local.player notsolid

				local.laserhit = (trace local.laserorigin (local.laserorigin + ( local.laservec * 10000 )))

				local.player solid

				if ($(local.bodytarget) != NULL)
				{
					$(local.bodytarget) notsolid
				}

				local.ent.origin = local.laserhit
				local.ent endpoint local.laserorigin

				if (!local.ent.laseron)
				{
					local.player loopsound local.lasersound local.soundvol
					local.ent damage local.player 0
					local.ent activate
					local.ent lightOn
					local.ent.laseron = 1
				}
			}
		} else
		{
			if (local.ent.laseron)
			{
				if (local.player.useheld)
				{
					local.canuse = 0
				}
				local.player stoploopsound
				local.ent lightOff
				local.ent deactivate
				local.ent.laseron = 0
			}
			
			if (local.player.mef_pressingbutton)
			{
				local.canuse = 0
			}
			
			local.useheldtime = NIL
		}

		if (local.ent.hitbody && !local.hitbody)
		{
			local.ent color local.laserhitcolor
			local.ent light local.laserhitcolor[0] local.laserhitcolor[1] local.laserhitcolor[2] (local.lightrad * 2)
			local.hitbody = 1
			
			if (local.ent.laseron)
			{
				local.player loopsound local.meltingsound local.soundvol
			}
		} else if (!local.ent.hitbody && local.hitbody)
		{
			local.ent color local.lasercolor
			local.ent light local.lasercolor[0] local.lasercolor[1] local.lasercolor[2] (local.lightrad * 2)
			local.hitbody = 0

			if (local.ent.laseron)
			{
				local.player loopsound local.lasersound local.soundvol
			} else
			{
				local.ent lightOff
			}
		}

		waitframe
	}
	
	if (local.player != NULL)
	{
		local.player stoploopsound
	}
	
	local.ent lightOff
	local.ent remove
end


collision_check local.beamtargetname local.bodytargetname:
	local.ents = $(local.bodytargetname)
	local.beams = $(local.beamtargetname)
	
	for (local.i = 1; local.i < (local.beams.size + 1); local.i++)
	{
		local.beam = local.beams[local.i]
		local.beam.hitbody = 0
		if (local.beam.laseron && (local.beam.player != NULL) && (local.beam.player.dmteam == local.beam.team) && (local.beam.player.mef_pstate == "PSTATE_ALIVE"))
		{
			for (local.j = 1; local.j < (local.ents.size + 1); local.j++)
			{
				local.body = local.ents[local.j]
				
				if ((local.body isTouching local.beam) && !local.body.melted)
				{
					local.beam.hitbody = 1
					thread melt_body local.body local.beam.player local.beam
				}
			}
		}
	}
end


auto_collision_check:
	while (1)
	{
		waitthread collision_check "meltbeam_allies" "frozenbody_allies"
		wait 0.1
		waitthread collision_check "meltbeam_axis" "frozenbody_axis"
		wait 0.1
	}
end


add_frozenloc_to_list local.origin local.team:
	for (local.elem = level.ft_bodylocs[local.team]; local.elem != NIL; local.elem = local.elem.prevloc)
	{
		if (vector_within local.origin local.elem.origin 10.0)
		{
			local.existing = 1
			break
		}
	}

	if (local.existing)
	{
		if (local.elem != level.ft_bodylocs[local.team])
		{
			// its not at front,  move it there
			if (local.elem.prevloc != NIL)
			{
				local.elem.prevloc.nextloc = local.elem.nextloc
			}
			
			if (local.elem.nextloc != NIL)
			{
				local.elem.nextloc.prevloc = local.elem.prevloc
			}
		}
	} else
	{
		local.elem = local createListener
		local.elem.origin = local.origin

	}

	if (local.elem != level.ft_bodylocs[local.team])
	{
		local.elem.prevloc = level.ft_bodylocs[local.team]
		local.elem.nextloc = NIL
	
		if (local.elem.prevloc != NIL)
		{
			local.elem.prevloc.nextloc = local.elem
		}
	
		level.ft_bodylocs[local.team] = local.elem
	}

	// keep the size of the list to 15 locations
	local.numlocs = 0
	for (local.elem = level.ft_bodylocs[local.team]; local.elem != NIL; local.elem = local.elem.prevloc)
	{
		local.numlocs += 1
		local.firstloc = local.elem
	}

	if (local.numlocs > 15)
	{
		local.firstloc.nextloc.prevloc = NIL
		local.firstloc delete
	}
end


pop_frozenloc_from_list local.team:
	local.lastloc = level.ft_bodylocs[local.team]

	if (local.lastloc != NIL)
	{
		local.result = local.lastloc.origin
		
		for (local.elem = local.lastloc; local.elem != NIL; local.elem = local.elem.prevloc)
		{
			local.firstloc = local.elem
		}

		if (local.firstloc != local.lastloc)
		{
			level.ft_bodylocs[local.team] = local.lastloc.prevloc
			local.lastloc.prevloc.nextloc = NIL

			local.firstloc.prevloc = local.lastloc
			local.lastloc.nextloc = local.firstloc
			local.lastloc.prevloc = NIL
		}
	} else
	{
		// should never happen but stick them at the origin just in case it does
		local.result = ( 0.0 0.0 0.0 )
	}
end local.result
